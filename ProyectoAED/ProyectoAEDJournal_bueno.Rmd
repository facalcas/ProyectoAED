---
title: "Análisis de los Suicidios Registrados en España en el Periodo 2014-2023"
author:
  - name: "Fabián Calvo Castillo"
    allfil: "1"
  - name: "Mario Martínez Guillen"
    allfil: "1"
  - name: "Axel Valton Juan"
    allfil: "1"

affiliation:
  - num: 1
    address: |
      Máster Universitario en Ciencia de Datos -
      Universitat de València -
      ETSE 
    email: "facalcas@alumni.uv.es"

authorcitation: |
  Calvo, F.; Martínez, M.; Valton, A.

correspondence: |
  marcelino.martinez@uv.es;

journal: notspecified
type: article
status: submit

simplesummary: |
  Proyecto Análisis Exploratorio de los Datos.

abstract: |
  Una vez finalizado el proyecto hacer el Abstract, resumen de lo que se hizo y se concluyó no superior a las 200 palabras.


keywords: |
  Suicidios; Mortalidad por Suicidio; España; Estadísticas de Mortalidad; Salud Pública; Análisis Exploratorio de Datos; Visualización de Datos 
  

acknowledgement: |
  
authorcontributions: |
  
funding: |
  This research received no external funding.

institutionalreview: |
  Not applicable.

informedconsent: |
  Not applicable.

dataavailability: |
  Los datos analizados en este estudio están disponibles públicamente y fueron 
  obtenidos del Instituto Nacional de Estadística (INE).
  https://ine.es/dyngs/INEbase/operacion.htm?c=Estadistica_C&cid=1254736176780&menu=resultados&idp=1254735573175#_tabs-1254736194710

conflictsofinterest: |
  The authors declare no conflict of interest.

supplementary: |
 
abbreviations:
  - short: MDPI
    long: Multidisciplinary Digital Publishing Institute
  - short: INE
    long: Instituto Nacional de Estadística

bibliography: mybibfile.bib
appendix: appendix.tex
endnotes: false

output: 
  rticles::mdpi_article:
    extra_dependencies: longtable
---


# Introducción

El suicidio representa un grave problema de salud pública en España, y en todo el mundo, cuya compresión es fundamental para el desarrollo de estrategias de prevención efectivas. El análisis de datos sobre este tema es el primer paso para hacer frente a la problemática con una base empírica sólida para la toma de decisiones.
Este estudio realiza un análisis exploratorio de los datos registrados a la mortalidad por suicidio en España durante el periodo de 2014 al 2023. El objetivo principal es identificar y describir patrones, tendencias, disparidades demográficas, geográficas y etarias en los datos registrados por el INE. Se busca responder preguntas clave sobre la distribución de los suicidios a lo largo del tiempo en territorio español.
Para alcanzar este objetivo, el análisis se estructura en torno a tres conjuntos de datos diferenciados, el primero de ellos examina la distribución de casos por año, comunidad autónoma, sexo y edad. El segundo conjunto presenta datos repartidos por el mes en el que ocurrió el suceso. Finalmente el tercer conjunto introduce la variable nacionalidad, sobre los casos de mortalidad por suicidio registrados en España.
A través de la exploración y visualización de dichas variables, el trabajo pretende describir la magnitud de la problemática que se enfrenta, y también identificar relaciones entre las variables analizadas. 

# Método

## Preparación y Adquisición de los Datos

El análisis se fundamenta en los datos de mortalidad por suicidio en España para el periodo de 2014 a 2023, proporcionados por el INE.
El punto de partida consistió en múltiples archivos .csv (uno para cada año de estudio), los cuales presentaban un formato estructurado, pero con trabajo por hacer en cuanto al formato de columnas y su distinción por año.
Las librerías utilizadas para este análisis se presentan acontinuación.
```{r}
pacman::p_load(tidyverse,lubridate,dplyr,stringr,readr,purrr)
```
El primer paso fue verificar la codificación de los conjuntos de datos, con el resultado que los conjuntos de Nacionalidad y Sexo y el conjunto de Comunidad Autónoma, Sexo y Edad comparten codificación, siendo esta la `ISO-8859-1`. Mientras que el conjunto de datos de Mes, Sexo y Edad presenta una codificación de `UTF-8`.

```{r Codificacion ns, include=FALSE}
guess_encoding("../data/2014ns.csv")
```

```{r Codificacion CSE, include=FALSE}
guess_encoding("../data/2014_CSE.csv")
```

```{r Codificación MSE, include=FALSE}
guess_encoding("../data/2014_MSE.csv")
```

Por esta razón, la importación de los conjuntos de datos se realiza en la codificación respectiva, y el análisis y graficación de los datos parte de la codificación asignada.

```{r MSE a Tidy, include=FALSE}
MSE <- data.frame(
  "Mes de defunción" = character(),
  Sexo = character(),
  Edad = character(),
  Total = numeric(),
  stringsAsFactors = FALSE
)

colnames(MSE)[1] <- "Mes de defunción"

cargar_y_añadir_MSE <- function(MSE, archivo){
  MSE_año <- read_delim(paste0("../data/",archivo), 
    delim = ";", escape_double = FALSE, trim_ws = TRUE, locale = locale(grouping_mark = ".",encoding="UTF-8"))
  MSE_año$Año <- gsub(pattern = "_[^1-9]*","", x = archivo)
  MSE <- rbind(MSE,MSE_año)
  return(MSE)
}

lista_archivos <- grep(x = list.files("../data"), pattern="[1-9]*_MSE.*", value= TRUE)
for (archivo in lista_archivos){
  MSE <- cargar_y_añadir_MSE(MSE, archivo)
}

MSE[colnames(MSE)!="Total"] <- as.data.frame(lapply(MSE[colnames(MSE)!="Total"],as.factor))

colnames(MSE)[colnames(MSE)=="Total"] <- "Total_suicidios"

MSE <- MSE %>% 
  select(Año,"Mes de defunción", Sexo, Edad, Total_suicidios)

MSE_sin_totales <- MSE %>%
  filter(`Mes de defunción`!="Todos los meses", Sexo!="Ambos sexos", Edad!="Todas las edades")
```

```{r CSE a Tidy, include=FALSE}
archivos<-list.files("../data")

archivos<-grep("CSE\\.csv$", archivos, value = TRUE)

CSE_tidy<-data.frame()

for (CSE in archivos){
  ruta <- paste0("../data/",CSE)
  encoding<-guess_encoding(ruta)[[1]][1]
  
  df <- read_delim(ruta, delim = ";", 
                   escape_double = FALSE, col_types = cols(Sexo = col_character(),Total=col_number()), 
                   locale = locale(encoding = encoding,grouping_mark=".",decimal_mark = ","), 
                   trim_ws = TRUE)
  
  names(df)[2]<-"Territorio"
  
  df<-df %>%
    filter(Nacional!="Extranjero")
  
  df<-df[-1]
  
  df <- df %>% replace_na(list(Territorio = "Nacional"))
  
  año_texto<- sub("_.*", "", CSE)
  
  año<-factor(año_texto, levels = 2014:2023)
  
  df <- df %>%
    mutate(Año = año)
  
  df <- df %>%
    mutate(
      Territorio = Territorio %>%
        str_squish() %>%
        str_remove("^\\d+\\s+") %>%
        str_remove(",.*$") %>%
        str_replace("Balears", "Baleares")
  )

  df <- df %>%
    mutate(
      Edad = Edad %>%
        str_replace("Todas.*", "Todas") %>%
        str_replace("años", "") %>%
        str_replace("De ", "") %>%
        str_replace("Menores de ", "<") %>%
        str_replace(" y más", "+") %>%
        str_replace(" a ", "-")
  )

  df <- df %>%
    mutate(
      Sexo = Sexo %>%
        str_replace("Ambos.*", "Ambos")
  )
  
  df <- df %>%
    filter(
      Territorio != "Nacional",
      Sexo != "Ambos",
      Edad != "Todas"
    )

  df <- df %>%
    mutate(across(where(is.character), as.factor))

  CSE_tidy <- CSE_tidy %>% rbind(df)

CSE_tidy <- CSE_tidy %>% 
  select(Año,Territorio, Sexo, Edad, Total)

# # Para graficar la pirámide de población
# CSE_graf <- CSE_tidy %>%
#   # Para que un sexo se dibuje “hacia la izquierda” y otro hacia la derecha, una de las poblaciones debe ser negativa:
#   mutate(Total = ifelse(Sexo == "Hombres", -Total, Total)) %>%
#   filter(Sexo != "Ambos") %>%
#   filter(Edad != "Todas") %>%
#   filter(Territorio == "Nacional") %>%
#   select(Año,Sexo,Edad,Total)
# # Para graficar el mapa
# CSE_map <- CSE_tidy %>%
#   filter(Sexo == "Ambos") %>%
#   filter(Edad == "Todas") %>%
#   filter(Territorio != "Nacional") %>%
#   select(Año,Territorio,Total)
 }
```

```{r ns a Tidy, include=FALSE}
procesar_archivo_ns <- function(archivo_ns) {
  patron_ns <- "(\\d+)ns\\.csv"
  matches_ns <- str_match(archivo_ns, patron_ns)
  año_extraido_ns <- as.numeric(matches_ns[1, 2])

  datos_ns_limpios <- read_delim(
    archivo_ns,
    delim = ";",
    escape_double = FALSE,
    trim_ws = TRUE,
    locale = locale(encoding = "ISO-8859-1", decimal_mark = ","),
    col_types = cols(
      Edad = col_character(),
      Nacionalidad = col_character(),
      Sexo = col_character(),
      Total = col_number()
      ),
    show_col_types = FALSE
    ) %>%
    
    filter(Edad == "Todas las edades") %>%
    filter(Nacionalidad != "Total" & Sexo != "Ambos sexos") %>%
    select(Nacionalidad, Sexo, Total) %>%
    mutate(
      Año = factor(año_extraido_ns,levels = 2014:2023),
      Nacionalidad = factor(Nacionalidad, levels = c("Española", "Extranjera", "No consta")),
      Sexo = factor(Sexo, levels = c("Hombres", "Mujeres"))
      ) %>%
    select(Año, Nacionalidad, Sexo, Total)
  return(datos_ns_limpios)
}

lista_archivos_ns <- list.files(
  path = "../data/",
  pattern = "\\d+ns\\.csv$",
  full.names = TRUE
)

datos_ns_tidy <- map_dfr(lista_archivos_ns, procesar_archivo_ns)
```

Se destacan tareas de transformación y limpieza que se realizaron en los conjuntos de datos seleccionados como la creación de una variable `Año` para cada uno de los conjuntos, debido a que en los ficheros originales descargados desde la página del INE no se contaba con esta variable. Se implementó una función que mediante el uso de expresiones regulares extraía el año (proveniente del nombre del fichero .csv), y se crea la variable `Año` en base a esta extracción. También se destaca la gestión de la respectiva codificación del conjunto de datos para evitar problemas al importar los conjuntos además de la corrección en los tipos de datos, referentes a la variables numéricas y categóricas que cada dataset presenta.
Una vez los ficheros se han tratado, se procede a su concatenación para la creación de los tres respectivos conjuntos de datos que serán utilizados para el análisis en el proyecto.


## Inspección de los Datos

Con los datos consolidados, se realiza la inspección de las variables con las que se cuenta para el análisis, y se identifican diversas características presentes en cada uno de los datasets.

El conjunto de datos que cuenta con la información de nacionalidad y sexo, presenta la siguiente estructura. 

```{r Estructura ns, echo=FALSE}
glimpse(datos_ns_tidy)
```

Se destaca que la variable `Año` es un factor con niveles de 2014 a 2023, la variable `Sexo` es un factor con los niveles "Hombres" y "Mujeres", la variable `Nacionalidad` se trata como un factor de tres niveles siendo estos: "Española", "Extranjera" y "No Consta". Siendo el nivel `No consta` como personas que se han suicidado pero no se pudo comprobar la nacionalidad de la persona.
Como parte de las decisiones tomadas con este conjunto, se analiza la proporción que esta categoría presenta en los datos, con los siguientes resultados.

```{r, include=FALSE}
suicidios_barras_nacionalidad<-datos_ns_tidy%>%
  group_by(Nacionalidad)%>%
  summarise(Total_Suicidios=sum(Total),.groups="drop")%>%
  mutate(Porcentaje=Total_Suicidios/sum(Total_Suicidios),
         Etiqueta_Porcentaje=scales::percent(Porcentaje,accuracy=0.01))
```
```{r, echo=FALSE}
gr_barras_nacionalidad <- ggplot(suicidios_barras_nacionalidad,
                                 aes(x = reorder(Nacionalidad, -Total_Suicidios),
                                     y = Total_Suicidios,
                                     fill = Nacionalidad)) +
  geom_col() +
  geom_text(
    aes(label = Etiqueta_Porcentaje),
    position = position_stack(vjust = 0.5),
    color = "black",
    size = 4
  ) +
  labs(
    title = "Proporción Total de Suicidios por Nacionalidad (2014-2023)",
    fill = "Nacionalidad",
    x = "Nacionalidad",
    y = "Número Total de Suicidios"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16),
    legend.position = "none" 
  )

print(gr_barras_nacionalidad)

```

Como se observa en el gráfico, la proporción de datos de esta categoría es prácticamente nula, con apenas un 0.02%. Por esta razón, para el análisis de los datos de suicidio segmentados por `Nacionalidad` esta categoría no se toma en consideración.
Finalmente para este dataset, la variable `Total` cuenta con un total de 60 datos, donde se muestran el total de suicidios registrados por año, y la información dividida por la nacionalidad de las personas.
A continuación se presenta un resumen de los datos presentes en esta variable.
```{r, echo=FALSE}
datos_ns_tidy%>%
  filter(Nacionalidad!="No consta")%>%
  summarise(
    Mínimo=min(Total),
    Q1 = quantile(Total, 0.25, na.rm = TRUE),
    Mediana = median(Total, na.rm = TRUE),
    Media = mean(Total, na.rm = TRUE),
    Q3 = quantile(Total, 0.75, na.rm = TRUE),
    Maximo = max(Total, na.rm = TRUE),
    Valores_NA = sum(is.na(Total))
  )
```

El conjunto de datos que presentan los datos de suicidio, separados por mes, sexo y edad, presenta la siguiente estructura. 

```{r Estructura MSE, echo=FALSE}
glimpse(MSE_sin_totales)
```

Se disponen de 5 variables llamadas `Año`, `Mes de defunción`,`Sexo`,`Edad` y `Total_suicidios`. Los nombres de estas variables son suficientemente representativos, y todas son de tipo factor excepto la variable numérica de `Total_suicidios`.

En las variables `Mes de defunción`, `Sexo` y `Edad` se hizo la limpieza de categorías no necesarias como "Todos los meses", "Ambos sexos" y "Todas las edades"; esto para que en la visualización no se agregue ruido innecesario debido a que se tiene la capacidad de presentar esta información mediante agrupamientos de los datos.

Por último, se presentan los datos de la variable `Total_suicidios`.

```{r, echo=FALSE}
MSE_sin_totales%>%
  summarise(
    Mínimo=min(Total_suicidios,na.rm = TRUE),
    Q1 = quantile(Total_suicidios, 0.25, na.rm = TRUE),
    Mediana = median(Total_suicidios, na.rm = TRUE),
    Media = mean(Total_suicidios, na.rm = TRUE),
    Q3 = quantile(Total_suicidios, 0.75, na.rm = TRUE),
    Maximo = max(Total_suicidios, na.rm = TRUE),
    Valores_NA = sum(is.na(Total_suicidios))
  )
```

Como se observa, existen meses sin suicidios registrados, y el máximo registrado en un mes es de 45 personas (ocurrido en agosto de 2020). Finalmente se muestra que la media de suicidios es de 10.63. Se destaca que este conjunto no presenta valores `NA`.

Finalmente, el conjunto de datos con datos separados por Comunidad Autonóma presenta la siguiente estructura.

```{r Estructura CSE, echo=FALSE}
glimpse(CSE_tidy)
```

Se disponen de 5 variables llamadas `Año`, `Territorio`,`Sexo`,`Edad` y `Total`. Como se ha manejado en los otros datasets, se establecen factores para las variables `Año` (con el periodo de estudio de este proyecto), para la variable `Territorio` se establece un factor con 19 niveles que representan las Comunidades y Ciudades Autónomas españolas. Como en los anteriores conjuntos explicados, se establece un factor para `Sexo` y `Edad`, con los niveles analizados.

Finalmente la variable `Total` muestra el número de suicidios presentados en bajo las condiciones anteriormente explicadas. 
```{r, echo=FALSE}
CSE_tidy%>%
  summarise(
    Mínimo=min(Total,na.rm = TRUE),
    Q1 = quantile(Total, 0.25, na.rm = TRUE),
    Mediana = median(Total, na.rm = TRUE),
    Media = mean(Total, na.rm = TRUE),
    Q3 = quantile(Total, 0.75, na.rm = TRUE),
    Maximo = max(Total, na.rm = TRUE),
    Valores_NA = sum(is.na(Total))
  )
```

# Resultados

## Graficos Calendario

Una de las primeras preguntas que surgen a la hora de analizar nuestro caso de estudio es qué evolución ha tenido el número de suicidios a lo largo de los años. Para ello, podemos utilizar cualquiera de los 3 datasets que hemos comentado anteriormente, ya que todos ellos contienen ímplicitamente la información de los suicidios totales en cada año.
```{r grafico-defunciones a lo largo del tiempo}
library(ggplot2)
MSE_evolucion <-MSE %>% 
  filter(`Mes de defunción`=="Todos los meses", Sexo=="Ambos sexos", Edad=="Todas las edades")

MSE_evolucion %>% 
  ggplot(aes(x=Año, y=Total_suicidios)) + geom_point() + geom_line(group=1)+geom_vline(xintercept = "2020", linetype = "dashed", color = "red")
```
```{r}
#Quitamos totales
MSE_sin_totales <- MSE %>% 
  filter(`Mes de defunción`!="Todos los meses", Sexo!="Ambos sexos",Edad!="Todas las edades")
```


```{r boxplot por meses MSE}
library(plotly)
p<-MSE %>% 
  filter(`Mes de defunción`!="Todos los meses", Sexo!="Ambos sexos", Edad!="Todas las edades") %>% 
  group_by(`Mes de defunción`,Año) %>% 
  summarise(Total_sum=sum(Total_suicidios)) %>% 
  ggplot(aes(x=`Mes de defunción`, y=Total_sum))+ geom_boxplot()

p
#ggplotly(p)
```
```{r}
library(plotly)
for (año in unique(MSE$Año)) {
  
  df_year <- MSE_sin_totales %>% 
    filter(Año == año) %>%
    group_by(`Mes de defunción`, Sexo) %>% 
    summarise(Total_sum = sum(Total_suicidios), .groups = "drop")
  
  p <- ggplot(df_year, aes(x = `Mes de defunción`, y=Total_sum)) +
        geom_bar(stat="identity", aes(fill=Sexo), position="dodge") +
        ggtitle(paste("Año:", año))
  
  #print(ggplotly(p))
}

```
```{r}
# library(plotly)
# library(dplyr)
# 
# anios <- unique(MSE_sin_totales$Año)
# sexos <- unique(MSE_sin_totales$Sexo)
# 
# fig <- plot_ly()
# 
# # --- Generar trazas por AÑO × SEXO ---
# for (a in seq_along(anios)) {
#   for (s in seq_along(sexos)) {
#     
#     df <- MSE_sin_totales %>% 
#       filter(Año == anios[a], Sexo == sexos[s])
#     
#     fig <- fig %>%
#       add_bars(
#         data = df,
#         x = ~`Mes de defunción`,
#         y = ~Total,
#         name = paste(anios[a], sexos[s]),
#         visible = ifelse(a == 1, TRUE, FALSE)
#       )
#   }
# }
# 
# # Cantidad de trazas por año
# trazas_por_anio <- length(sexos)
# 
# fig <- fig %>%
#   layout(
#     barmode = "group",
#     updatemenus = list(
#       list(
#         type = "dropdown",
#         buttons = lapply(seq_along(anios), function(a){
#           # vector de visibilidad, uno por traza
#           visibles <- rep(FALSE, length(anios) * trazas_por_anio)
#           
#           # activar las trazas del año a
#           inicio <- (a - 1) * trazas_por_anio + 1
#           fin <- inicio + trazas_por_anio - 1
#           visibles[inicio:fin] <- TRUE
#           
#           list(
#             method = "update",
#             label = anios[a],
#             args = list(list(visible = visibles))
#           )
#         })
#       )
#     )
#   )
# 
# fig

```

## Graficas Lineas, Nacionalidades

```{r}
library(ggplot2)
library(dplyr)
library(plotly)
library(scales)
library(ggrepel)

suicidios_por_nacionalidad<-datos_ns_tidy%>%
  group_by(Año,Nacionalidad)%>%
  summarise(Total_Suicidios=sum(Total))%>%
  filter(Nacionalidad!="No consta")

suicidios_barras_nacionalidad<-datos_ns_tidy%>%
  group_by(Nacionalidad)%>%
  summarise(Total_Suicidios=sum(Total),.groups="drop")%>%
  mutate(Porcentaje=Total_Suicidios/sum(Total_Suicidios),
         Etiqueta_Porcentaje=scales::percent(Porcentaje,accuracy=0.01))

suicidios_por_año<-datos_ns_tidy%>%
  group_by(Año)%>%
  summarise(Total_Suicidios=sum(Total))


gr_por_año<-ggplot(suicidios_por_año, aes(x=Año, y=Total_Suicidios, group=1)) +
  geom_line(color="blue") +
  geom_point(color="blue") +
  labs(title = "Evolución del Total de Suicidios en España (2014-2023)",
       y = "Número de Suicidios",
       x = "Año") +
  theme_minimal()

# En el código de este gráfico es importante el group=1 porque como los años están como factor, para que los tome cada uno como un valor del eje

print(gr_por_año)



# gra_barras_nac<-plot_ly(
#   data=suicidios_por_nacionalidad,
#   x= ~Nacionalidad, y= ~Total_Suicidios,
#   color = ~Nacionalidad,
#   type="bar",
#   frame= ~Año,
#   customdata= ~Total_Suicidios,
#   hovertemplate=paste0(
#     "<b>%{x}</b><br>",
#     "Total: %{y}",
#     "<extra></extra>"
#     )
#   ) %>%
#   layout(
#     title=list(text="Suicidios en España por Nacionalidad"),
#     xaxis=list(title="Nacionalidad"),
#     yaxis=list(title="Número de Suicidios"),
#     showlegend=F
#   ) %>%
#   animation_slider(
#     currentvalue=list(prefix="Año: ")
#   ) %>%
#   animation_opts(
#     frame=600,
#     easing="linear",
#     redraw=F
#   )
# 
# print(gra_barras_nac)

gr_barras_nacionalidad <- ggplot(suicidios_barras_nacionalidad,
                                 aes(x = reorder(Nacionalidad, -Total_Suicidios),
                                     y = Total_Suicidios,
                                     fill = Nacionalidad)) +
  geom_col() +
  geom_text(
    aes(label = Etiqueta_Porcentaje),
    vjust = 1.5,
    color = "white",
    size = 4
  ) +
  labs(
    title = "Proporción Total de Suicidios por Nacionalidad (2014-2023)",
    fill = "Nacionalidad",
    x = "Nacionalidad",
    y = "Número Total de Suicidios"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16),
    legend.position = "none" 
  )

print(gr_barras_nacionalidad)
```

```{r}
library(readxl)
poblacion_NS <- read_excel("../data/poblacion_ASN.xlsx", skip=6, n_max = 9)
View(poblacion_NS)
```

```{r, poblaciones_ns}
library(readxl)
library(tidyverse)


df_tidy_poblacion_NS <- poblacion_NS %>%
  rename(cat = 1) %>%
  
  mutate(
    Nacionalidad = if_else(cat %in% c("Española", "Extranjera"), cat, NA_character_),
    edad         = if_else(cat == "Todas las edades", cat, NA_character_),
    Sexo         = if_else(cat %in% c("Hombres", "Mujeres"), cat, NA_character_)
  ) %>%
  
  fill(Nacionalidad, edad, Sexo) %>%
  
  filter(!(cat %in% c("Española", "Extranjera", "Todas las edades"))) %>%
  
  pivot_longer(
    cols = -c(cat, Nacionalidad, edad, Sexo),
    names_to = "fecha",
    values_to = "Poblacion"
  ) %>%
  
  mutate(
    Año = as.factor(str_extract(fecha, "\\d{4}") |> as.integer())
  ) %>%
  select(Año,Nacionalidad,Sexo,  Poblacion)


df_tidy_poblacion_NS <- datos_ns_tidy %>% filter(Nacionalidad!="No consta") %>% inner_join(df_tidy_poblacion_NS,by=c("Año","Nacionalidad","Sexo"))

df_tidy_poblacion_NS <- df_tidy_poblacion_NS %>%
  group_by(Año, Nacionalidad) %>%
  summarise(
    Suicidios_total = sum(Total, na.rm = TRUE),
    Poblacion_total = sum(Poblacion, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(Tasa_suicidios = Suicidios_total / Poblacion_total)


ggplot(df_tidy_poblacion_NS, aes(x = Año, y = Tasa_suicidios, color = Nacionalidad, group = Nacionalidad)) +
  geom_line(size = 1.2) +
  geom_point() +
  labs(
    title = "Tasa de suicidios por nacionalidad (total hombres + mujeres)",
    x = "Año",
    y = "Tasa de suicidios",
    color = "Nacionalidad"
  ) +
  theme_minimal()

```

```{r}
#Cargamos librerías para graficar
pacman::p_load(ggplot2,plotly,mapSpain,sf,scales)
```


##Grafica Piramide

```{r}
# library(ggplot2)
# 
# años<-levels(CSE_graf$Año)
# max_global <- max(abs(CSE_graf$Total))
# 
# for (año in años){
#   
#   data <- CSE_graf %>% 
#     filter(Año == año)
#   
# 
#   Grafico <-ggplot(data, aes(x = Edad, y = Total, fill = Sexo)) +
#     geom_col(width = 0.9) +
#     coord_flip() +
#     scale_y_continuous(labels = abs, limits = c(-max_global, max_global)) +
#     labs(
#       title = paste("Pirámide de suicidios",año),
#       x = "Edad",
#       y = "Suicidios",
#       fill = "Sexo"
#     ) +
#     theme_grey()
#   
#   print(Grafico)
#  
# }


```

```{r}
# brks <- pretty(c(0, max_global))
# tickvals <- c(-brks, brks)        # valores a ambos lados
# ticktext <- c(brks, brks)         # etiquetas siempre positivas
# 
# p <- plot_ly(
#   data = CSE_graf,
#   x = ~Total, y = ~Edad,
#   color = ~Sexo,
#   colors = c("Hombres" = "#E86E34", "Mujeres" = "#5E7CE2"),
#   type = "bar", orientation = "h",
#   frame = ~Año,
#   hovertemplate = "Edad: %{y}<br>Suicidios: %{customdata}<extra></extra>",
#   customdata = ~abs(Total)
# ) %>%
#   layout(
#     barmode = "relative",
#     # ----- Título centrado + más espacio arriba -----
#     title = list(text = "Pirámide de suicidios", x = 0.5, xanchor = "center",
#                  font = list(size = 22)),
#     margin = list(t = 90),                # más margen superior para el título
# 
#     # ----- Ejes -----
#     xaxis = list(
#       title = "Suicidios",
#       range = c(-(max_global+50), (max_global+50)),
#       tickvals = tickvals,
#       ticktext = ticktext,
#       zeroline = FALSE                    # quitamos la zeroline para usar la nuestra
#     ),
#     yaxis = list(title = "Edad"),
# 
#     # ----- Leyenda dentro de la trama -----
#     legend = list(
#       x = 0.98, y = 0.98,                 # esquina sup. derecha
#       xanchor = "right", yanchor = "top",
#       bgcolor = "rgba(255,255,255,0.75)", # caja semitransparente
#       bordercolor = "rgba(0,0,0,0.2)",
#       borderwidth = 1,
#       orientation = "v",
#       font = list(size = 12)
#     ),
# 
#     # ----- (Opcional) línea vertical en x=0 -----
#     shapes = list(list(
#       type = "line", x0 = 0, x1 = 0, xref = "x",
#       y0 = 0, y1 = 1, yref = "paper",
#       line = list(color = "rgba(0,0,0,0.6)", width = 1)
#     )),
# 
#     bargap = 0.15
#   ) %>%
#   animation_slider(currentvalue = list(prefix = "Año: ")) %>%
#   animation_opts(frame = 600, easing = "linear", redraw = FALSE)
# 
# p
```

## Grafica Mapa

```{r}
# #Cargamos las geometrías de las comunidades autonomas
# 
# ccaa<-esp_get_ccaa(moveCAN = T) %>% st_as_sf()
# 
# # Modificamos los nombres de las comunidades para que sea mas friendly
#   
# ccaa<-ccaa %>%
#   mutate(
#     Territorio = ine.ccaa.name %>%
#       # 1) Quitar espacios extremos
#       str_squish() %>%
#       # 2) Quitar prefijo numérico
#       str_remove("^\\d+\\s+") %>%
#       # 3) Quedarse con lo anterior a la primera coma
#       str_remove(",.*$") %>%
#       # 4) Casos excepcionales
#       str_replace("Balears", "Baleares")
#   ) %>%
#   # Filtramos columnas inecesarias
#   select(Territorio,geometry)
# 
# #Unimos la info
# 
# CSE_map<- ccaa %>%
#   left_join(CSE_map, by = "Territorio")
# 
# 
# ```
# 
# ```{r}
# for (año in años) {
#   
#   # Mapa base
#   g_mapa <- CSE_map %>%
#     filter(Año == año) %>%
#     ggplot() +
#     geom_sf(aes(fill = Total), color = "white", linewidth = 0.25) +
#   
#     # Escala en grises
#     scale_fill_stepsn(
#       colours = grey(seq(0.9, 0.1, length.out = 7)),
#       n.breaks = 7,
#       trans = "sqrt",
#       na.value = "grey95",
#       name = "Suicidios",
#       labels = label_comma()
#     ) +
#   
#     # solo el mapa (sin título ni leyenda “encima”)
#     theme_void() + #esto me quita las coordenadas
#     theme(
#       panel.background = element_rect(fill = "grey95", color = NA),
#       plot.background  = element_rect(fill = "grey95", color = "grey80", linewidth = 0.6),
#       legend.position = "none",   # quitamos la leyenda aquí (la añadimos fuera)
#       
#     ) +
#     # Añadimos titulo y leyenda fuera
#     labs(title = paste("Suicidios por CCAA —", año)) +
#     theme(
#       plot.title.position = "plot",
#       plot.background = element_rect(fill = "white", color = NA),
#       panel.background = element_rect(fill = "grey95", color = NA),
#       legend.position = "right"
#     )
#   
#   print(g_mapa)
    
#}
```
```{r}


# # Escala fija (opcional) para que todos los años compartan el mismo máximo
# zmax <- max(CSE_map$Total, na.rm = TRUE)
# 
# # Paleta en grises (claro -> oscuro)
# pal_grey <- grey(seq(0.95, 0.2, length.out = 7))
# 
# p_mapa <- plot_ly() %>%
#   add_sf(
#     data  = CSE_map,
#     split = ~Territorio,            # una traza por CCAA
#     frame = ~Año,                   # <-- slider por año
#     color = ~Total,                 # colorear por Total
#     colors = pal_grey,              # paleta en grises
#     text = ~paste0(
#       "<b>", Territorio, "</b><br>",
#       "Suicidios: ", comma(Total)
#     ),
#     hoverinfo = "text",
#     stroke = I("white"),            # borde blanco entre CCAA
#     span = I(1)                     # relleno sólido del polígono
#   ) %>%
#   layout(
#     title  = list(text = "Suicidios por CCAA", x = 0.5, xanchor = "center",
#                   font = list(size = 22)),
#     margin = list(t = 80, r = 110, b = 20, l = 20),
#     # Barra de color (leyenda) a la derecha, fuera del mapa
#     coloraxis = list(
#       colorscale = list(c(0, pal_grey[1]), c(1, pal_grey[length(pal_grey)])),
#       cmin = 0, cmax = zmax,
#       colorbar = list(title = "Suicidios", len = 0.8, x = 1.04, y = 0.5)
#     ),
#     showlegend = FALSE
#   ) %>%
#   animation_slider(currentvalue = list(prefix = "Año: ")) %>%
#   animation_opts(frame = 600, easing = "linear", redraw = FALSE)
# 
# p_mapa

```


## Subsection Heading Here

.

### Subsubsection Heading Here

Bulleted lists look like this:

* First bullet
* Second bullet
* Third bullet

Numbered lists can be added as follows:

1. First item
2. Second item
3. Third item

The text continues here.

## Figures, Tables and Schemes

All figures and tables should be cited in the main text as Figure \ref{fig:fig1}, 
\ref{tab:tab1}, etc. To get cross-reference to figure generated by R chunks 
include the `\\label{}` tag in the `fig.cap` attribute of the R chunk: 
`fig.cap = "Fancy Caption\\label{fig:plot}"`.

```{r fig1, echo=FALSE, fig.width=3, fig.cap="A figure added with a code chunk.\\label{fig:fig1}"}
x = rnorm(10)
y = rnorm(10)
plot(x, y)
```


When making tables using `kable`, it is suggested to use
the `format="latex"` and `tabl.envir="table"` arguments
to ensure table numbering and compatibility with the mdpi
document class.

```{r tab1, echo=FALSE}
knitr::kable(mtcars[1:5, 1:3], format = "latex", 
             booktabs = TRUE, 
             caption = "This is a table caption. Tables should be placed in the 
             main text near to the first time they are~cited.", 
             align = 'ccc', centering = FALSE,
             table.envir = "table", position = "H")
```



For a very wide table, landscape layouts are allowed.


\startlandscape

```{r tab2, echo=FALSE}
df <- data.frame(`Title 1` = c("Entry 1", "Entry 2"),
                 `Title 2` = c("Data", "Data"),
                 `Title 3` = c("Data", "Data"),
                 `Title 4` = c("This cell has some longer content that runs over
                               two lines",
                               "Data"))
knitr::kable(df, format = "latex", 
             booktabs = TRUE, 
             caption = "This is a very wide table", 
             align = 'ccc', centering = FALSE,
             table.envir = "table", position = "H")
```

\finishlandscape

## Formatting of Mathematical Components

This is an example of an equation:

$$
a = 1.
$$

If you want numbered equations use Latex and wrap in the equation environment:

\begin{equation}
a = 1,
\end{equation}

the text following an equation need not be a new paragraph. Please punctuate 
equations as regular text.

```{comment}
If the documentclass option "submit" is chosen, please insert a blank line before and after any math environment (equation and eqnarray environments). This ensures correct linenumbering. The blank line should be removed when the documentclass option is changed to "accept" because the text following an equation should not be a new paragraph.
```

This is the example 2 of equation:

\begin{adjustwidth}{-\extralength}{0cm}
\begin{equation}
a = b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + 
u + v + w + x + y + z
\end{equation}
\end{adjustwidth}

Theorem-type environments (including propositions, lemmas, corollaries etc.) 
can be formatted as follows:

Example of a theorem:

::: {.Theorem latex=true}
Example text of a theorem
:::

The text continues here. Proofs must be formatted as follows:

Example of a proof:

::: {.proof latex="[Proof of Theorem1]"}
Text of the proof. Note that the phrase ``of Theorem 1'' is optional if it is 
clear which theorem is being referred to.
:::

The text continues here.

# Discussion

Authors should discuss the results and how they can be interpreted in 
perspective of previous studies and of the working hypotheses. The findings and 
their implications should be discussed in the broadest context possible. Future 
research directions may also be highlighted.

# Conclusion

This section is not mandatory, but can be added to the manuscript if the
discussion is unusually long or complex.

# Patents

This section is not mandatory, but may be added if there are patents resulting
from the work reported in this manuscript.

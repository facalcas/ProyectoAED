---
title: "Análisis de los Suicidios Registrados en España en el Periodo 2014-2023"
author:
  - name: "Fabián Calvo Castillo"
    allfil: "1"
  - name: "Mario Martínez Guillen"
    allfil: "1"
  - name: "Axel Valton Juan"
    allfil: "1"

affiliation:
  - num: 1
    address: |
      Máster Universitario en Ciencia de Datos -
      Universitat de València -
      ETSE 
    email: "facalcas@alumni.uv.es"

authorcitation: |
  Calvo, F.; Martínez, M.; Valton, A.

correspondence: |
  marcelino.martinez@uv.es;

journal: notspecified
type: article
status: submit

simplesummary: |
  Proyecto Análisis Exploratorio de los Datos.

abstract: |
  Una vez finalizado el proyecto hacer el Abstract, resumen de lo que se hizo y se concluyó no superior a las 200 palabras.


keywords: |
  Suicidios; Mortalidad por Suicidio; España; Estadísticas de Mortalidad; Salud Pública; Análisis Exploratorio de Datos; Visualización de Datos 
  

acknowledgement: |
  
authorcontributions: |
  
funding: |
  This research received no external funding.

institutionalreview: |
  Not applicable.

informedconsent: |
  Not applicable.

dataavailability: |
  Los datos analizados en este estudio están disponibles públicamente y fueron 
  obtenidos del Instituto Nacional de Estadística (INE).
  https://ine.es/dyngs/INEbase/operacion.htm?c=Estadistica_C&cid=1254736176780&menu=resultados&idp=1254735573175#_tabs-1254736194710

conflictsofinterest: |
  The authors declare no conflict of interest.

supplementary: |
 
abbreviations:
  - short: MDPI
    long: Multidisciplinary Digital Publishing Institute
  - short: INE
    long: Instituto Nacional de Estadística

bibliography: mybibfile.bib
appendix: appendix.tex
endnotes: false

output: 
  rticles::mdpi_article:
    extra_dependencies: longtable
---


# Introducción

El suicidio representa un grave problema de salud pública en España, y en todo el mundo, cuya compresión es fundamental para el desarrollo de estrategias de prevención efectivas. El análisis de datos sobre este tema es el primer paso para hacer frente a la problemática con una base empírica sólida para la toma de decisiones.
Este estudio realiza un análisis exploratorio de los datos registrados a la mortalidad por suicidio en España durante el periodo de 2014 al 2023. El objetivo principal es identificar y describir patrones, tendencias, disparidades demográficas, geográficas y etarias en los datos registrados por el INE. Se busca responder preguntas clave sobre la distribución de los suicidios a lo largo del tiempo en territorio español.
Para alcanzar este objetivo, el análisis se estructura en torno a tres conjuntos de datos diferenciados, el primero de ellos examina la distribución de casos por año, comunidad autónoma, sexo y edad. El segundo conjunto presenta datos repartidos por el mes en el que ocurrió el suceso. Finalmente el tercer conjunto introduce la variable nacionalidad, sobre los casos de mortalidad por suicidio registrados en España.
A través de la exploración y visualización de dichas variables, el trabajo pretende describir la magnitud de la problemática que se enfrenta, y también identificar relaciones entre las variables analizadas. 

# Método

## Preparación y Adquisición de los Datos

El análisis se fundamenta en los datos de mortalidad por suicidio en España para el periodo de 2014 a 2023, proporcionados por el INE.
El punto de partida consistió en múltiples archivos .csv (uno para cada año de estudio), los cuales presentaban un formato estructurado, pero con trabajo por hacer en cuanto al formato de columnas y su distinción por año.
Las librerías utilizadas para este análisis se presentan acontinuación.
```{r}
pacman::p_load(tidyverse,lubridate,dplyr,stringr,readr,purrr)
```
El primer paso fue verificar la codificación de los conjuntos de datos, con el resultado que los conjuntos de Nacionalidad y Sexo y el conjunto de Comunidad Autónoma, Sexo y Edad comparten codificación, siendo esta la `ISO-8859-1`. Mientras que el conjunto de datos de Mes, Sexo y Edad presenta una codificación de `UTF-8`.

```{r Codificacion ns, include=FALSE}
guess_encoding("../data/2014ns.csv")
```

```{r Codificacion CSE, include=FALSE}
guess_encoding("../data/2014_CSE.csv")
```

```{r Codificación MSE, include=FALSE}
guess_encoding("../data/2014_MSE.csv")
```

Por esta razón, la importación de los conjuntos de datos se realiza en la codificación respectiva, y el análisis y graficación de los datos parte de la codificación asignada.

```{r MSE a Tidy, include=FALSE}
MSE <- data.frame(
  "Mes de defunción" = character(),
  Sexo = character(),
  Edad = character(),
  Total = numeric(),
  stringsAsFactors = FALSE
)

colnames(MSE)[1] <- "Mes de defunción"

cargar_y_añadir_MSE <- function(MSE, archivo){
  MSE_año <- read_delim(paste0("../data/",archivo), 
    delim = ";", escape_double = FALSE, trim_ws = TRUE, locale = locale(grouping_mark = ".",encoding="UTF-8"))
  MSE_año$Año <- gsub(pattern = "_[^1-9]*","", x = archivo)
  MSE <- rbind(MSE,MSE_año)
  return(MSE)
}

lista_archivos <- grep(x = list.files("../data"), pattern="[1-9]*_MSE.*", value= TRUE)
for (archivo in lista_archivos){
  MSE <- cargar_y_añadir_MSE(MSE, archivo)
}

MSE[colnames(MSE)!="Total"] <- as.data.frame(lapply(MSE[colnames(MSE)!="Total"],as.factor))

colnames(MSE)[colnames(MSE)=="Total"] <- "Total_suicidios"

MSE <- MSE %>% 
  select(Año,"Mes de defunción", Sexo, Edad, Total_suicidios)
```

```{r CSE a Tidy, include=FALSE}
archivos<-list.files("../data")

archivos<-grep("CSE\\.csv$", archivos, value = TRUE)

CSE_tidy<-data.frame()

for (CSE in archivos){
  ruta <- paste0("../data/",CSE)
  encoding<-guess_encoding(ruta)[[1]][1]
  
  df <- read_delim(ruta, delim = ";", 
                   escape_double = FALSE, col_types = cols(Sexo = col_character(),Total=col_number()), 
                   locale = locale(encoding = encoding,grouping_mark=".",decimal_mark = ","), 
                   trim_ws = TRUE)
  
  names(df)[2]<-"Territorio"
  
  df<-df %>%
    filter(Nacional!="Extranjero")
  
  df<-df[-1]
  
  df <- df %>% replace_na(list(Territorio = "Nacional"))
  
  año_texto<- sub("_.*", "", CSE)
  
  año<-factor(año_texto, levels = 2014:2023)
  
  df <- df %>%
    mutate(Año = año)
  
  df <- df %>%
    mutate(
      Territorio = Territorio %>%
        str_squish() %>%
        str_remove("^\\d+\\s+") %>%
        str_remove(",.*$") %>%
        str_replace("Balears", "Baleares")
  )

  df <- df %>%
    mutate(
      Edad = Edad %>%
        str_replace("Todas.*", "Todas") %>%
        str_replace("años", "") %>%
        str_replace("De ", "") %>%
        str_replace("Menores de ", "<") %>%
        str_replace(" y más", "+") %>%
        str_replace(" a ", "-")
  )

  df <- df %>%
    mutate(
      Sexo = Sexo %>%
        str_replace("Ambos.*", "Ambos")
  )
  
  df <- df %>%
    filter(
      Territorio != "Nacional",
      Sexo != "Ambos",
      Edad != "Todas"
    )

  df <- df %>%
    mutate(across(where(is.character), as.factor))

  CSE_tidy <- CSE_tidy %>% rbind(df)

CSE_tidy <- CSE_tidy %>% 
  select(Año,Territorio, Sexo, Edad, Total)

# # Para graficar la pirámide de población
# CSE_graf <- CSE_tidy %>%
#   # Para que un sexo se dibuje “hacia la izquierda” y otro hacia la derecha, una de las poblaciones debe ser negativa:
#   mutate(Total = ifelse(Sexo == "Hombres", -Total, Total)) %>%
#   filter(Sexo != "Ambos") %>%
#   filter(Edad != "Todas") %>%
#   filter(Territorio == "Nacional") %>%
#   select(Año,Sexo,Edad,Total)
# # Para graficar el mapa
# CSE_map <- CSE_tidy %>%
#   filter(Sexo == "Ambos") %>%
#   filter(Edad == "Todas") %>%
#   filter(Territorio != "Nacional") %>%
#   select(Año,Territorio,Total)
 }
```

```{r ns a Tidy, include=FALSE}
procesar_archivo_ns <- function(archivo_ns) {
  patron_ns <- "(\\d+)ns\\.csv"
  matches_ns <- str_match(archivo_ns, patron_ns)
  año_extraido_ns <- as.numeric(matches_ns[1, 2])

  datos_ns_limpios <- read_delim(
    archivo_ns,
    delim = ";",
    escape_double = FALSE,
    trim_ws = TRUE,
    locale = locale(encoding = "ISO-8859-1", decimal_mark = ","),
    col_types = cols(
      Edad = col_character(),
      Nacionalidad = col_character(),
      Sexo = col_character(),
      Total = col_number()
      ),
    show_col_types = FALSE
    ) %>%
    
    filter(Edad == "Todas las edades") %>%
    filter(Nacionalidad != "Total" & Sexo != "Ambos sexos") %>%
    select(Nacionalidad, Sexo, Total) %>%
    mutate(
      Año = factor(año_extraido_ns,levels = 2014:2023),
      Nacionalidad = factor(Nacionalidad, levels = c("Española", "Extranjera", "No consta")),
      Sexo = factor(Sexo, levels = c("Hombres", "Mujeres"))
      ) %>%
    select(Año, Nacionalidad, Sexo, Total)
  return(datos_ns_limpios)
}

lista_archivos_ns <- list.files(
  path = "../data/",
  pattern = "\\d+ns\\.csv$",
  full.names = TRUE
)

datos_ns_tidy <- map_dfr(lista_archivos_ns, procesar_archivo_ns)
```

Se destacan tareas de transformación y limpieza que se realizaron en los conjuntos de datos seleccionados como la creación de una variable `Año` para cada uno de los conjuntos, debido a que en los ficheros originales descargados desde la página del INE no se contaba con esta variable. Se implementó una función que mediante el uso de expresiones regulares extraía el año (proveniente del nombre del fichero .csv), y se crea la variable `Año` en base a esta extracción. También se destaca la gestión de la respectiva codificación del conjunto de datos para evitar problemas al importar los conjuntos además de la corrección en los tipos de datos, referentes a la variables numéricas y categóricas que cada dataset presenta.
Una vez los ficheros se han tratado, se procede a su concatenación para la creación de los tres respectivos conjuntos de datos que serán utilizados para el análisis en el proyecto.


## Inspección de los Datos

Con los datos consolidados, se realiza la inspección de las variables con las que se cuenta para el análisis, y se identifican diversas características presentes en cada uno de los datasets.

El conjunto de datos que cuenta con la información de nacionalidad y sexo, presenta la siguiente estructura. 

```{r Estructura ns, echo=FALSE}
glimpse(datos_ns_tidy)
```

Se destaca que la variable `Año` es un factor con niveles de 2014 a 2023, la variable `Sexo` es un factor con los niveles "Hombres" y "Mujeres", la variable `Nacionalidad` se trata como un factor de tres niveles siendo estos: "Española", "Extranjera" y "No Consta". Siendo el nivel `No consta` como personas que se han suicidado pero no se pudo comprobar la nacionalidad de la persona.
Como parte de las decisiones tomadas con este conjunto, se analiza la proporción que esta categoría presenta en los datos, con los siguientes resultados.

```{r, include=FALSE}
suicidios_barras_nacionalidad<-datos_ns_tidy%>%
  group_by(Nacionalidad)%>%
  summarise(Total_Suicidios=sum(Total),.groups="drop")%>%
  mutate(Porcentaje=Total_Suicidios/sum(Total_Suicidios),
         Etiqueta_Porcentaje=scales::percent(Porcentaje,accuracy=0.01))
```
```{r, echo=FALSE}
gr_barras_nacionalidad <- ggplot(suicidios_barras_nacionalidad,
                                 aes(x = reorder(Nacionalidad, -Total_Suicidios),
                                     y = Total_Suicidios,
                                     fill = Nacionalidad)) +
  geom_col() +
  geom_text(
    aes(label = Etiqueta_Porcentaje),
    position = position_stack(vjust = 0.5),
    color = "black",
    size = 4
  ) +
  labs(
    title = "Proporción Total de Suicidios por Nacionalidad (2014-2023)",
    fill = "Nacionalidad",
    x = "Nacionalidad",
    y = "Número Total de Suicidios"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16),
    legend.position = "none" 
  )

print(gr_barras_nacionalidad)

```

Como se observa en el gráfico, la proporción de datos de esta categoría es prácticamente nula, con apenas un 0.02%. Por esta razón, para el análisis de los datos de suicidio segmentados por `Nacionalidad` esta categoría no se toma en consideración.
Finalmente para este dataset, la variable `Total` cuenta con un total de 60 datos, donde se muestran el total de suicidios registrados por año, y la información dividida por la nacionalidad de las personas.
A continuación se presenta un resumen de los datos presentes en esta variable.
```{r}
datos_ns_tidy%>%
  filter(Nacionalidad!="No consta")
```





Tras transformar nuestro dataset a formato `tidy` y haber concatenado los distintos años, vamos a analizar un poco cada una de las variables.

Nuestras variables en este conjunto de datos son las siguientes:


```{r, echo = FALSE}
str(MSE)
```
Vemos pues que disponemos de 5 variables llamadas `Año`, `Mes de defunción`,`Sexo`,`Edad` y `Total_suicidios`. Los nombres de estas vemos que son suficientemente representativos, y todas son de tipo factor excepto la de `Total_suicidios` que es numérica. Nótese que la variable año se ha codificado como factor en lugar de fecha porque únicamente sirve como representación categórica para clasificar anualmente los datos.

Vamos a inspeccionar un poco cada una de las variables.

En cuanto al `Año`, si miramos los distintos valores que puede tomar vemos que efectivamente tenemos datos de los años desde 2014 hasta 2023.

```{r, echo=FALSE}
levels(MSE$Año)
```
Por otro lado, como cabría esperar la variable `Mes de defunción` dispone de todos los meses del año, pero vemos una particularidad, tenemos un agregado de "Todos los meses":


En cuanto al `Sexo` disponemos de "Hombres" y "Mujeres" y, además, de nuevo tenemos un agregado de "Ambos sexos".

```{r, echo=FALSE}
levels(MSE$Sexo)
```

Para la última variable tipo factor (`Edad`) tenemos las siguientes categorías:

```{r, echo=FALSE}
levels(MSE$Edad)
```

Como podemos observar, tenemos también un agregado de "Todas las edades".

En vista de los datos tipo factor, realizamos una reordenación de los meses y las edades, así como una eliminación de las filas correspondientes a los registros "Ambos sexos","Todas las edades" y "Todos los meses".

```{r, echo=FALSE}
library(tidyverse)
MSE$`Mes de defunción` <- factor(MSE$`Mes de defunción`, levels=c("enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre", "Todos los meses"))

MSE$Edad <- factor(MSE$Edad, levels=c("Todas las edades","Menores de 15 años","De 15 a 29 años","De 30 a 39 años","De 40 a 44 años","De 45 a 49 años","De 50 a 54 años","De 55 a 59 años","De 60 a 64 años","De 65 a 69 años","De 70 a 74 años","De 75 a 79 años","De 80 a 84 años","De 85 a 89 años","De 90 a 94 años","De 95 años y más"))
MSE_sin_totales <- MSE %>% 
  filter(`Mes de defunción`!="Todos los meses", Sexo!="Ambos sexos", Edad!="Todas las edades")
```

Por último, la variable `Total_suicidios` hemos dicho que es una variable numérica. Explorémosla un poco numéricamente. Para ello, saquemos estadísticos por mes.

```{r, echo=FALSE}
summary(MSE_sin_totales$Total_suicidios)
```

Como vemos, hay meses, edades y sexos donde no se suicida nadie, y el máximo son 45. Así mismo, de media entre todas las edades, sexos y meses se suicidan 10.63 personas.

Además, este conjunto de datos no presentan datos faltantes:

```{r, echo = FALSE}
sum(is.na(MSE_sin_totales))
```

## Tidy dataset CA, Sexo y Edad

Una vez importado el conjunto de datos de los suicidios repartidos por comunidad autónoma y su respectiva transformación a un conjunto en formato tidy, el resultante es un dataframe con las siguientes variables:

```{r, echo=FALSE}
colnames(CSE_tidy)
```
La clase de estas variables es la siguiente:

```{r, echo=FALSE}
str(CSE_tidy)
```
Siendo la variable `Año` un factor con los años de 2014 a 2023, la variable `Territorio` un factor con las 19 Comunidades Autónomas de España, incluyendo las ciudades autónomas, y un Total nacional, la variable `Sexo` un factor con dos niveles siendo estos Hombres y Mujeres; la variable `Edad` cuenta con 15 niveles siendo estos los siguientes:
```{r, echo=FALSE}
levels(CSE_tidy$Edad)
```
Finalmente la variable `Total` muestra el número de suicidios presentados en bajo las condiciones anteriormente explicadas. Se verifica la presencia de valores ausentes en la variable `Total` con el siguiente resultado:
```{r, echo=FALSE}
sum(is.na(CSE_tidy$Total))
```

## Nacionalidad y Sexo

Una vez importada los datos de suicidios en España distribuidos por la nacionalidad de las personas, se cuenta con un dateframe que cuenta con cuatro variables siendo estas:

```{r, echo=FALSE}
print(colnames(datos_ns_tidy))
```

La clase de estas variable son:
```{r, echo=FALSE}
print(str(datos_ns_tidy))
```

Se tiene que la variable `Año` es un factor con niveles de 2014 a 2023, la variable `Nacionalidad` de las personas se trata como un factor de tres niveles siendo estos: Española, Extranjera y No Consta. Siendo el nivel "No consta" como personas que se han suicidado pero no se pudo comprobar la nacionalidad de la persona. 

```{r, echo=FALSE}
suicidios_barras_nacionalidad<-datos_ns_tidy%>%
  group_by(Nacionalidad)%>%
  summarise(Total_Suicidios=sum(Total),.groups="drop")%>%
  mutate(Porcentaje=Total_Suicidios/sum(Total_Suicidios),
         Etiqueta_Porcentaje=scales::percent(Porcentaje,accuracy=0.01))

gr_barras_nacionalidad <- ggplot(suicidios_barras_nacionalidad,
                                 aes(x = reorder(Nacionalidad, -Total_Suicidios),
                                     y = Total_Suicidios,
                                     fill = Nacionalidad)) +
  geom_col() +
  geom_text(
    aes(label = Etiqueta_Porcentaje),
    vjust = 1.5,
    color = "white",
    size = 4
  ) +
  labs(
    title = "Proporción Total de Suicidios por Nacionalidad (2014-2023)",
    fill = "Nacionalidad",
    x = "Nacionalidad",
    y = "Número Total de Suicidios"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16),
    legend.position = "none" 
  )

print(gr_barras_nacionalidad)

```

Como se puede observar en este gráfico, la proporción de datos de suicidios de personas de las que no se cuenta la nacionalidad es sumamente bajo. Por esta razón se prescindirán de estos registros para el análisis posterior de los datos segmentados por la nacionalidad de las personas.  

La variable `Sexo` cuenta con niveles Hombre y Mujer, y el número de suicidios se muestra en la variable `Total` y es de tipo numérica.
Se tiene un total de 60 datos, donde se muestran el total de suicidios registrados por año, y la información dividida por la nacionalidad de las personas. 













Para nuestro caso de estudio, hemos obtenido los datos de suicidios proporcionados por el Instituto Nacional de Estadística (INE).
En particular hemos importado los datos de suicidios de 2014 a 2023 divididos en 3 datasets.

Uno de ellos contiene un desglose por sexo, edad y mes de defunción; otro de ellos añade el desglose de la nacionalidad; y el último de ellos añade la comunidad autónoma.

Dichos datasets provenían de archivos tipo excels distintos (uno por año) que vienen en formato no tidy y que previamente a todo el tratamiento se transformarán a formato tidy y se concatenarán.

Posteriormente, se realizará una inspección de cada una de las variables para entender nuestros conjuntos de datos y se obtendrán descripciones gráficas del número de suicidios, relativizándolas cuando se considere a través de datasets de población obtenidos también en el INE.

Por último, veremos si existe alguna relación entre alguno de nuestros factores y el número total de suicidios.


<!-- ## Inspección de los datos -->

<!-- ### Mes de defunción sexo y edad -->
<!-- ## Mes, Sexo y Edad -->
<!-- ```{r Codificacion MSE, echo=FALSE} -->
<!-- guess_encoding("../data/2014_MSE.csv") -->
<!-- #Tienen codificación UTF-8 -->
<!-- ``` -->

<!-- ```{r MSE, echo=FALSE} -->

<!--  # Creamos dataframe base vacío -->
<!--  MSE <- data.frame( -->
<!--    "Mes de defunción" = character(), -->
<!--    Sexo = character(), -->
<!--    Edad = character(), -->
<!--    Total = numeric(), -->
<!--    stringsAsFactors = FALSE -->
<!--  ) -->

<!--  colnames(MSE)[1] <- "Mes de defunción" -->

<!--  # Función para ir concatenando los dataframes anuales -->
<!--  cargar_y_añadir_MSE <- function(MSE, archivo){ -->
<!--    MSE_año <- read_delim(paste0("../data/",archivo),  -->
<!--      delim = ";", escape_double = FALSE, trim_ws = TRUE, locale = locale(grouping_mark = ".")) -->
<!--    MSE_año$Año <- gsub(pattern = "_[^1-9]*","", x = archivo) -->
<!--    MSE <- rbind(MSE,MSE_año) -->
<!--    return(MSE) -->
<!--  } -->

<!--  lista_archivos <- grep(x = list.files("../data"), pattern="[1-9]*_MSE.*", value= TRUE) -->
<!--  for (archivo in lista_archivos){ -->
<!--    MSE <- cargar_y_añadir_MSE(MSE, archivo) -->
<!--  } -->

<!--  # Convertimos los datos al tipo correcto -->
<!--  MSE[colnames(MSE)!="Total"] <- as.data.frame(lapply(MSE[colnames(MSE)!="Total"],as.factor)) -->

<!--  #Renombramos variable Total para que sea más explicativa -->

<!--  colnames(MSE)[colnames(MSE)=="Total"] <- "Total_suicidios" -->

<!--  # Reordenamos las columnas -->
<!--  MSE <- MSE %>%  -->
<!--    select(Año,"Mes de defunción", Sexo, Edad, Total_suicidios) -->
<!-- ``` -->
<!-- Tras transformar nuestro dataset a formato `tidy` y haber concatenado los distintos años, vamos a analizar un poco cada una de las variables. -->

<!-- Nuestras variables en este conjunto de datos son las siguientes: -->


<!-- ```{r, echo = FALSE} -->
<!-- str(MSE) -->
<!-- ``` -->
<!-- Vemos pues que disponemos de 5 variables llamadas `Año`, `Mes de defunción`,`Sexo`,`Edad` y `Total_suicidios`. Los nombres de estas vemos que son suficientemente representativos, y todas son de tipo factor excepto la de `Total_suicidios` que es numérica. Nótese que la variable año se ha codificado como factor en lugar de fecha porque únicamente sirve como representación categórica para clasificar anualmente los datos. -->

<!-- Vamos a inspeccionar un poco cada una de las variables. -->

<!-- En cuanto al `Año`, si miramos los distintos valores que puede tomar vemos que efectivamente tenemos datos de los años desde 2014 hasta 2023. -->

<!-- ```{r, echo=FALSE} -->
<!-- levels(MSE$Año) -->
<!-- ``` -->
<!-- Por otro lado, como cabría esperar la variable `Mes de defunción` dispone de todos los meses del año, pero vemos una particularidad, tenemos un agregado de "Todos los meses": -->


<!-- En cuanto al `Sexo` disponemos de "Hombres" y "Mujeres" y, además, de nuevo tenemos un agregado de "Ambos sexos". -->

<!-- ```{r, echo=FALSE} -->
<!-- levels(MSE$Sexo) -->
<!-- ``` -->

<!-- Para la última variable tipo factor (`Edad`) tenemos las siguientes categorías: -->

<!-- ```{r, echo=FALSE} -->
<!-- levels(MSE$Edad) -->
<!-- ``` -->

<!-- Como podemos observar, tenemos también un agregado de "Todas las edades". -->

<!-- En vista de los datos tipo factor, realizamos una reordenación de los meses y las edades, así como una eliminación de las filas correspondientes a los registros "Ambos sexos","Todas las edades" y "Todos los meses". -->

<!-- ```{r, echo=FALSE} -->
<!-- library(tidyverse) -->
<!-- MSE$`Mes de defunción` <- factor(MSE$`Mes de defunción`, levels=c("enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre", "Todos los meses")) -->

<!-- MSE$Edad <- factor(MSE$Edad, levels=c("Todas las edades","Menores de 15 años","De 15 a 29 años","De 30 a 39 años","De 40 a 44 años","De 45 a 49 años","De 50 a 54 años","De 55 a 59 años","De 60 a 64 años","De 65 a 69 años","De 70 a 74 años","De 75 a 79 años","De 80 a 84 años","De 85 a 89 años","De 90 a 94 años","De 95 años y más")) -->
<!-- MSE_sin_totales <- MSE %>%  -->
<!--   filter(`Mes de defunción`!="Todos los meses", Sexo!="Ambos sexos", Edad!="Todas las edades") -->
<!-- ``` -->

<!-- Por último, la variable `Total_suicidios` hemos dicho que es una variable numérica. Explorémosla un poco numéricamente. Para ello, saquemos estadísticos por mes. -->

<!-- ```{r, echo=FALSE} -->
<!-- summary(MSE_sin_totales$Total_suicidios) -->
<!-- ``` -->
<!-- Como vemos, hay meses, edades y sexos donde no se suicida nadie, y el máximo son 45. Así mismo, de media entre todas las edades, sexos y meses se suicidan 10.63 personas. -->



















<!-- ## Tidy dataset CA, Sexo y Edad -->

<!-- ```{r, echo=FALSE} -->
<!-- # Cargar la ubicación del archivo -->

<!-- archivos<-list.files("../data") -->

<!-- # Filtramos por los que terminan en _CSE.csv usando una expresion regular -->
<!-- archivos<-grep("CSE\\.csv$", archivos, value = TRUE) -->

<!-- # Creamos un df vacío en el que almacenar nuestros datos tratados y limpios -->
<!-- CSE_tidy<-data.frame() -->

<!-- for (CSE in archivos){ -->

<!--   # Generamos la ruta del archivo -->

<!--   ruta <- paste0("../data/",CSE) -->

<!--   # Cargamos el dataframe -->

<!--   encoding<-guess_encoding(ruta)[[1]][1] -->

<!--   df <- read_delim(ruta, delim = ";",  -->
<!--                    escape_double = FALSE, col_types = cols(Sexo = col_character(),Total=col_number()),  -->
<!--                    locale = locale(encoding = encoding,grouping_mark=".",decimal_mark = ","),  -->
<!--                    trim_ws = TRUE) -->

<!--   names(df)[2]<-"Territorio" -->

<!--   # Nos centramos solo en el ámbito Nacional -->

<!--   df<-df %>% -->
<!--     filter(Nacional!="Extranjero") -->

<!--   # Eliminamos la columna Nacional -->

<!--   df<-df[-1] -->

<!--   # Sustituímos los NAs por Nacional -->

<!--   df <- df %>% replace_na(list(Territorio = "Nacional")) -->

<!--   # Creamos la columna año: -->

<!--   # Primero extraemos el año del nombre del archivo -->

<!--   año_texto<- sub("_.*", "", CSE) #busca el patron y lo borra, así me quedo con la fecha -->

<!--   # Ahora lo pasamos a variable tipo factor -->

<!--   año<-factor(año_texto, levels = 2014:2023) -->

<!--   df <- df %>% -->
<!--     mutate(Año = año) -->

<!--   # Modificamos los nombres de las comunidades para que sea mas friendly -->

<!--   df <- df %>% -->
<!--     mutate( -->
<!--       Territorio = Territorio %>% -->
<!--         # 1) Quitar espacios extremos -->
<!--         str_squish() %>% -->
<!--         # 2) Quitar prefijo numérico -->
<!--         str_remove("^\\d+\\s+") %>% -->
<!--         # 3) Quedarse con lo anterior a la primera coma -->
<!--         str_remove(",.*$") %>% -->
<!--         # 4) Casos excepcionales -->
<!--         str_replace("Balears", "Baleares") -->

<!--   ) -->

<!--   #Modificamos Sexo, Edad de la misma forma -->
<!--   df <- df %>% -->
<!--     mutate( -->
<!--       Edad = Edad %>% -->
<!--         str_replace("Todas.*", "Todas") %>% -->
<!--         str_replace("años", "") %>% -->
<!--         str_replace("De ", "") %>% -->
<!--         str_replace("Menores de ", "<") %>% -->
<!--         str_replace(" y más", "+") %>% -->
<!--         str_replace(" a ", "-") -->

<!--   ) -->

<!--   df <- df %>% -->
<!--     mutate( -->
<!--       Sexo = Sexo %>% -->
<!--         str_replace("Ambos.*", "Ambos") -->

<!--   ) -->

<!--   df <- df %>% -->
<!--     filter( -->
<!--       Territorio != "Nacional", -->
<!--       Sexo != "Ambos", -->
<!--       Edad != "Todas" -->
<!--     ) -->


<!--   #Ahora cabiaremos a tipo factor las otras columnas Territorio, Sexo, Edad -->

<!--   df <- df %>% -->
<!--     mutate(across(where(is.character), as.factor)) -->
<!--   #Finalmente apilamos en un único dataframe los datos de cada año -->

<!--   CSE_tidy <- CSE_tidy %>% rbind(df) -->

<!--   # Reordenamos las columnas -->
<!-- CSE_tidy <- CSE_tidy %>%  -->
<!--   select(Año,Territorio, Sexo, Edad, Total) -->

<!-- # Para graficar la pirámide de población -->
<!-- CSE_graf <- CSE_tidy %>% -->
<!--   # Para que un sexo se dibuje “hacia la izquierda” y otro hacia la derecha, una de las poblaciones debe ser negativa: -->
<!--   mutate(Total = ifelse(Sexo == "Hombres", -Total, Total)) %>% -->
<!--   filter(Sexo != "Ambos") %>% -->
<!--   filter(Edad != "Todas") %>% -->
<!--   filter(Territorio == "Nacional") %>% -->
<!--   select(Año,Sexo,Edad,Total) -->
<!-- # Para graficar el mapa -->
<!-- CSE_map <- CSE_tidy %>% -->
<!--   filter(Sexo == "Ambos") %>% -->
<!--   filter(Edad == "Todas") %>% -->
<!--   filter(Territorio != "Nacional") %>% -->
<!--   select(Año,Territorio,Total) -->
<!-- } -->
<!-- ``` -->

<!-- Una vez importado el conjunto de datos de los suicidios repartidos por comunidad autónoma y su respectiva transformación a un conjunto en formato tidy, el resultante es un dataframe con las siguientes variables: -->

<!-- ```{r, echo=FALSE} -->
<!-- colnames(CSE_tidy) -->
<!-- ``` -->
<!-- La clase de estas variables es la siguiente: -->

<!-- ```{r, echo=FALSE} -->
<!-- str(CSE_tidy) -->
<!-- ``` -->
<!-- Siendo la variable `Año` un factor con los años de 2014 a 2023, la variable `Territorio` un factor con las 19 Comunidades Autónomas de España, incluyendo las ciudades autónomas, y un Total nacional, la variable `Sexo` un factor con dos niveles siendo estos Hombres y Mujeres; la variable `Edad` cuenta con 15 niveles siendo estos los siguientes: -->
<!-- ```{r, echo=FALSE} -->
<!-- levels(CSE_tidy$Edad) -->
<!-- ``` -->
<!-- Finalmente la variable `Total` muestra el número de suicidios presentados en bajo las condiciones anteriormente explicadas. Se verifica la presencia de valores ausentes en la variable `Total` con el siguiente resultado: -->
<!-- ```{r, echo=FALSE} -->
<!-- sum(is.na(CSE_tidy$Total)) -->
<!-- ``` -->




<!-- ## Nacionalidad y Sexo -->

<!-- ```{r, echo=FALSE} -->
<!-- readr::guess_encoding(file="../data/2023ns.csv", n= 1000) -->

<!-- # Se crea la función procesar_archivo_ns que hace tidy un solo archivo de ns -->

<!-- procesar_archivo_ns <- function(archivo_ns) { -->
<!--   patron_ns <- "(\\d+)ns\\.csv" -->
<!--   matches_ns <- str_match(archivo_ns, patron_ns) -->
<!--   año_extraido_ns <- as.numeric(matches_ns[1, 2]) -->

<!-- # La expresión regular para sacar el año es: (\\d+) [que significa encuentra un dígito y lo que está después de él] ns [toma también "ns" literal] \\. [toma también un . literal] csv [toma también los caracteres csv] [de esta forma identifica el patrón específico de los archivos guardados de nacionalidad-sexo ns] -->
<!-- # La función str_match empareja la ruta de los archivos ns con su respectivo patrón separado por año -->
<!-- # Con año_extraido_ns  -->

<!--   datos_ns_limpios <- read_delim( -->
<!--     archivo_ns, -->
<!--     delim = ";", -->
<!--     escape_double = FALSE, -->
<!--     trim_ws = TRUE, -->
<!--     locale = locale(encoding = "ISO-8859-1", decimal_mark = ","), -->
<!--     col_types = cols( -->
<!--       Edad = col_character(), -->
<!--       Nacionalidad = col_character(), -->
<!--       Sexo = col_character(), -->
<!--       Total = col_number() -->
<!--       ), -->
<!--     show_col_types = FALSE -->
<!--     ) %>% -->

<!-- # Con esta porción del código se importan los archivos ns de la carpeta data, con el encoding adecuado, y desde aquí se le asigna las columnas su tipo adecuado. show_col_types = F es para no llenar la consola de los tipos de las columnas   -->

<!--     dplyr::filter(Edad == "Todas las edades") %>% -->
<!--     dplyr::filter(Nacionalidad != "Total" & Sexo != "Ambos sexos") %>% -->
<!--     select(Nacionalidad, Sexo, Total) %>% -->
<!--     mutate( -->
<!--       Año = factor(año_extraido_ns,levels = 2014:2023), -->
<!--       Nacionalidad = factor(Nacionalidad, levels = c("Española", "Extranjera", "No consta")), -->
<!--       Sexo = factor(Sexo, levels = c("Hombres", "Mujeres")) -->
<!--       ) %>% -->
<!--     select(Año, Nacionalidad, Sexo, Total) -->
<!--   return(datos_ns_limpios) -->
<!-- } -->

<!-- # Con esta porción de código se filtran las edades para que no muestre toda la segmentación sino que muestre los valores Totales (se aprovecha que desde el propio dataset original ya viene el número total de suicidios sumado), con el segundo filter se "eliminan" errores que venían en estas columnas como "Total" en Nacionalidades y "Ambos sexos" para de esta forma mostrar las 3 tipos de nacionalidad que interesa y los dos sexos. Se seleccionan las columnas que nos interesan, con el mutate se crea la columna Año con el año_extraido_ns definido en pasos anteriores, y las columnas Nacionalidad y Sexo se hacen factor con los valores respectivos. Con el último select se ordenan las columnas para que sea más fácil de entender al mirar la tabla.  -->

<!-- lista_archivos_ns <- list.files( -->
<!--   path = "../data/", -->
<!--   pattern = "\\d+ns\\.csv$", -->
<!--   full.names = TRUE -->
<!-- ) -->

<!-- # Con esta porción de código se crea una lista con los documentos que hay en la carpeta data que cumplen con el patrón de ns (explicado anteriormente) y toma tods esos archivos. -->

<!-- datos_ns_tidy <- map_dfr(lista_archivos_ns, procesar_archivo_ns) -->

<!-- # Se hace uso de una función de purrr que es map_dfr y lo que hace es que a la lista de archivos que cumplen con el patrón de ns les aplica la función de hacerlos tidy, y lo que hace es crear dataframes individuales que concatena en un gran dataframe con todos los archivos en formato tidy en 1 -->
<!-- ``` -->

<!-- Una vez importada los datos de suicidios en España distribuidos por la nacionalidad de las personas, se cuenta con un dateframe que cuenta con cuatro variables siendo estas: -->

<!-- ```{r, echo=FALSE} -->
<!-- print(colnames(datos_ns_tidy)) -->
<!-- ``` -->

<!-- La clase de estas variable son: -->
<!-- ```{r, echo=FALSE} -->
<!-- print(str(datos_ns_tidy)) -->
<!-- ``` -->

<!-- Se tiene que la variable `Año` es un factor con niveles de 2014 a 2023, la variable `Nacionalidad` de las personas se trata como un factor de tres niveles siendo estos: Española, Extranjera y No Consta. Siendo el nivel "No consta" como personas que se han suicidado pero no se pudo comprobar la nacionalidad de la persona.  -->

<!-- ```{r, echo=FALSE} -->
<!-- suicidios_barras_nacionalidad<-datos_ns_tidy%>% -->
<!--   group_by(Nacionalidad)%>% -->
<!--   summarise(Total_Suicidios=sum(Total),.groups="drop")%>% -->
<!--   mutate(Porcentaje=Total_Suicidios/sum(Total_Suicidios), -->
<!--          Etiqueta_Porcentaje=scales::percent(Porcentaje,accuracy=0.01)) -->

<!-- gr_barras_nacionalidad <- ggplot(suicidios_barras_nacionalidad, -->
<!--                                  aes(x = reorder(Nacionalidad, -Total_Suicidios), -->
<!--                                      y = Total_Suicidios, -->
<!--                                      fill = Nacionalidad)) + -->
<!--   geom_col() + -->
<!--   geom_text( -->
<!--     aes(label = Etiqueta_Porcentaje), -->
<!--     vjust = 1.5, -->
<!--     color = "white", -->
<!--     size = 4 -->
<!--   ) + -->
<!--   labs( -->
<!--     title = "Proporción Total de Suicidios por Nacionalidad (2014-2023)", -->
<!--     fill = "Nacionalidad", -->
<!--     x = "Nacionalidad", -->
<!--     y = "Número Total de Suicidios" -->
<!--   ) + -->
<!--   theme_minimal() + -->
<!--   theme( -->
<!--     plot.title = element_text(hjust = 0.5, size = 16), -->
<!--     legend.position = "none"  -->
<!--   ) -->

<!-- print(gr_barras_nacionalidad) -->

<!-- ``` -->

<!-- Como se puede observar en este gráfico, la proporción de datos de suicidios de personas de las que no se cuenta la nacionalidad es sumamente bajo. Por esta razón se prescindirán de estos registros para el análisis posterior de los datos segmentados por la nacionalidad de las personas.   -->

<!-- La variable `Sexo` cuenta con niveles Hombre y Mujer, y el número de suicidios se muestra en la variable `Total` y es de tipo numérica. -->
<!-- Se tiene un total de 60 datos, donde se muestran el total de suicidios registrados por año, y la información dividida por la nacionalidad de las personas.  -->

# Results

## Graficos Calendario

Una de las primeras preguntas que surgen a la hora de analizar nuestro caso de estudio es qué evolución ha tenido el número de suicidios a lo largo de los años. Para ello, podemos utilizar cualquiera de los 3 datasets que hemos comentado anteriormente, ya que todos ellos contienen ímplicitamente la información de los suicidios totales en cada año.
```{r grafico-defunciones a lo largo del tiempo}
library(ggplot2)
MSE_evolucion <-MSE %>% 
  filter(`Mes de defunción`=="Todos los meses", Sexo=="Ambos sexos", Edad=="Todas las edades")

MSE_evolucion %>% 
  ggplot(aes(x=Año, y=Total_suicidios)) + geom_point() + geom_line(group=1)+geom_vline(xintercept = "2020", linetype = "dashed", color = "red")
```
```{r}
#Quitamos totales
MSE_sin_totales <- MSE %>% 
  filter(`Mes de defunción`!="Todos los meses", Sexo!="Ambos sexos",Edad!="Todas las edades")
```


```{r boxplot por meses MSE}
library(plotly)
p<-MSE %>% 
  filter(`Mes de defunción`!="Todos los meses", Sexo!="Ambos sexos", Edad!="Todas las edades") %>% 
  group_by(`Mes de defunción`,Año) %>% 
  summarise(Total_sum=sum(Total_suicidios)) %>% 
  ggplot(aes(x=`Mes de defunción`, y=Total_sum))+ geom_boxplot()

p
#ggplotly(p)
```
```{r}
library(plotly)
for (año in unique(MSE$Año)) {
  
  df_year <- MSE_sin_totales %>% 
    filter(Año == año) %>%
    group_by(`Mes de defunción`, Sexo) %>% 
    summarise(Total_sum = sum(Total_suicidios), .groups = "drop")
  
  p <- ggplot(df_year, aes(x = `Mes de defunción`, y=Total_sum)) +
        geom_bar(stat="identity", aes(fill=Sexo), position="dodge") +
        ggtitle(paste("Año:", año))
  
  #print(ggplotly(p))
}

```
```{r}
# library(plotly)
# library(dplyr)
# 
# anios <- unique(MSE_sin_totales$Año)
# sexos <- unique(MSE_sin_totales$Sexo)
# 
# fig <- plot_ly()
# 
# # --- Generar trazas por AÑO × SEXO ---
# for (a in seq_along(anios)) {
#   for (s in seq_along(sexos)) {
#     
#     df <- MSE_sin_totales %>% 
#       filter(Año == anios[a], Sexo == sexos[s])
#     
#     fig <- fig %>%
#       add_bars(
#         data = df,
#         x = ~`Mes de defunción`,
#         y = ~Total,
#         name = paste(anios[a], sexos[s]),
#         visible = ifelse(a == 1, TRUE, FALSE)
#       )
#   }
# }
# 
# # Cantidad de trazas por año
# trazas_por_anio <- length(sexos)
# 
# fig <- fig %>%
#   layout(
#     barmode = "group",
#     updatemenus = list(
#       list(
#         type = "dropdown",
#         buttons = lapply(seq_along(anios), function(a){
#           # vector de visibilidad, uno por traza
#           visibles <- rep(FALSE, length(anios) * trazas_por_anio)
#           
#           # activar las trazas del año a
#           inicio <- (a - 1) * trazas_por_anio + 1
#           fin <- inicio + trazas_por_anio - 1
#           visibles[inicio:fin] <- TRUE
#           
#           list(
#             method = "update",
#             label = anios[a],
#             args = list(list(visible = visibles))
#           )
#         })
#       )
#     )
#   )
# 
# fig

```

## Graficas Lineas, Nacionalidades

```{r}
library(ggplot2)
library(dplyr)
library(plotly)
library(scales)
library(ggrepel)

suicidios_por_nacionalidad<-datos_ns_tidy%>%
  group_by(Año,Nacionalidad)%>%
  summarise(Total_Suicidios=sum(Total))%>%
  filter(Nacionalidad!="No consta")

suicidios_barras_nacionalidad<-datos_ns_tidy%>%
  group_by(Nacionalidad)%>%
  summarise(Total_Suicidios=sum(Total),.groups="drop")%>%
  mutate(Porcentaje=Total_Suicidios/sum(Total_Suicidios),
         Etiqueta_Porcentaje=scales::percent(Porcentaje,accuracy=0.01))

suicidios_por_año<-datos_ns_tidy%>%
  group_by(Año)%>%
  summarise(Total_Suicidios=sum(Total))


gr_por_año<-ggplot(suicidios_por_año, aes(x=Año, y=Total_Suicidios, group=1)) +
  geom_line(color="blue") +
  geom_point(color="blue") +
  labs(title = "Evolución del Total de Suicidios en España (2014-2023)",
       y = "Número de Suicidios",
       x = "Año") +
  theme_minimal()

# En el código de este gráfico es importante el group=1 porque como los años están como factor, para que los tome cada uno como un valor del eje

print(gr_por_año)



# gra_barras_nac<-plot_ly(
#   data=suicidios_por_nacionalidad,
#   x= ~Nacionalidad, y= ~Total_Suicidios,
#   color = ~Nacionalidad,
#   type="bar",
#   frame= ~Año,
#   customdata= ~Total_Suicidios,
#   hovertemplate=paste0(
#     "<b>%{x}</b><br>",
#     "Total: %{y}",
#     "<extra></extra>"
#     )
#   ) %>%
#   layout(
#     title=list(text="Suicidios en España por Nacionalidad"),
#     xaxis=list(title="Nacionalidad"),
#     yaxis=list(title="Número de Suicidios"),
#     showlegend=F
#   ) %>%
#   animation_slider(
#     currentvalue=list(prefix="Año: ")
#   ) %>%
#   animation_opts(
#     frame=600,
#     easing="linear",
#     redraw=F
#   )
# 
# print(gra_barras_nac)

gr_barras_nacionalidad <- ggplot(suicidios_barras_nacionalidad,
                                 aes(x = reorder(Nacionalidad, -Total_Suicidios),
                                     y = Total_Suicidios,
                                     fill = Nacionalidad)) +
  geom_col() +
  geom_text(
    aes(label = Etiqueta_Porcentaje),
    vjust = 1.5,
    color = "white",
    size = 4
  ) +
  labs(
    title = "Proporción Total de Suicidios por Nacionalidad (2014-2023)",
    fill = "Nacionalidad",
    x = "Nacionalidad",
    y = "Número Total de Suicidios"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16),
    legend.position = "none" 
  )

print(gr_barras_nacionalidad)
```

```{r}
library(readxl)
poblacion_NS <- read_excel("../data/poblacion_ASN.xlsx", skip=6, n_max = 9)
View(poblacion_NS)
```

```{r, poblaciones_ns}
library(readxl)
library(tidyverse)


df_tidy_poblacion_NS <- poblacion_NS %>%
  rename(cat = 1) %>%
  
  mutate(
    Nacionalidad = if_else(cat %in% c("Española", "Extranjera"), cat, NA_character_),
    edad         = if_else(cat == "Todas las edades", cat, NA_character_),
    Sexo         = if_else(cat %in% c("Hombres", "Mujeres"), cat, NA_character_)
  ) %>%
  
  fill(Nacionalidad, edad, Sexo) %>%
  
  filter(!(cat %in% c("Española", "Extranjera", "Todas las edades"))) %>%
  
  pivot_longer(
    cols = -c(cat, Nacionalidad, edad, Sexo),
    names_to = "fecha",
    values_to = "Poblacion"
  ) %>%
  
  mutate(
    Año = as.factor(str_extract(fecha, "\\d{4}") |> as.integer())
  ) %>%
  select(Año,Nacionalidad,Sexo,  Poblacion)


df_tidy_poblacion_NS <- datos_ns_tidy %>% filter(Nacionalidad!="No consta") %>% inner_join(df_tidy_poblacion_NS,by=c("Año","Nacionalidad","Sexo"))

df_tidy_poblacion_NS <- df_tidy_poblacion_NS %>%
  group_by(Año, Nacionalidad) %>%
  summarise(
    Suicidios_total = sum(Total, na.rm = TRUE),
    Poblacion_total = sum(Poblacion, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(Tasa_suicidios = Suicidios_total / Poblacion_total)


ggplot(df_tidy_poblacion_NS, aes(x = Año, y = Tasa_suicidios, color = Nacionalidad, group = Nacionalidad)) +
  geom_line(size = 1.2) +
  geom_point() +
  labs(
    title = "Tasa de suicidios por nacionalidad (total hombres + mujeres)",
    x = "Año",
    y = "Tasa de suicidios",
    color = "Nacionalidad"
  ) +
  theme_minimal()

```

```{r}
#Cargamos librerías para graficar
pacman::p_load(ggplot2,plotly,mapSpain,sf,scales)
```


##Grafica Piramide

```{r}
# library(ggplot2)
# 
# años<-levels(CSE_graf$Año)
# max_global <- max(abs(CSE_graf$Total))
# 
# for (año in años){
#   
#   data <- CSE_graf %>% 
#     filter(Año == año)
#   
# 
#   Grafico <-ggplot(data, aes(x = Edad, y = Total, fill = Sexo)) +
#     geom_col(width = 0.9) +
#     coord_flip() +
#     scale_y_continuous(labels = abs, limits = c(-max_global, max_global)) +
#     labs(
#       title = paste("Pirámide de suicidios",año),
#       x = "Edad",
#       y = "Suicidios",
#       fill = "Sexo"
#     ) +
#     theme_grey()
#   
#   print(Grafico)
#  
# }


```

```{r}
# brks <- pretty(c(0, max_global))
# tickvals <- c(-brks, brks)        # valores a ambos lados
# ticktext <- c(brks, brks)         # etiquetas siempre positivas
# 
# p <- plot_ly(
#   data = CSE_graf,
#   x = ~Total, y = ~Edad,
#   color = ~Sexo,
#   colors = c("Hombres" = "#E86E34", "Mujeres" = "#5E7CE2"),
#   type = "bar", orientation = "h",
#   frame = ~Año,
#   hovertemplate = "Edad: %{y}<br>Suicidios: %{customdata}<extra></extra>",
#   customdata = ~abs(Total)
# ) %>%
#   layout(
#     barmode = "relative",
#     # ----- Título centrado + más espacio arriba -----
#     title = list(text = "Pirámide de suicidios", x = 0.5, xanchor = "center",
#                  font = list(size = 22)),
#     margin = list(t = 90),                # más margen superior para el título
# 
#     # ----- Ejes -----
#     xaxis = list(
#       title = "Suicidios",
#       range = c(-(max_global+50), (max_global+50)),
#       tickvals = tickvals,
#       ticktext = ticktext,
#       zeroline = FALSE                    # quitamos la zeroline para usar la nuestra
#     ),
#     yaxis = list(title = "Edad"),
# 
#     # ----- Leyenda dentro de la trama -----
#     legend = list(
#       x = 0.98, y = 0.98,                 # esquina sup. derecha
#       xanchor = "right", yanchor = "top",
#       bgcolor = "rgba(255,255,255,0.75)", # caja semitransparente
#       bordercolor = "rgba(0,0,0,0.2)",
#       borderwidth = 1,
#       orientation = "v",
#       font = list(size = 12)
#     ),
# 
#     # ----- (Opcional) línea vertical en x=0 -----
#     shapes = list(list(
#       type = "line", x0 = 0, x1 = 0, xref = "x",
#       y0 = 0, y1 = 1, yref = "paper",
#       line = list(color = "rgba(0,0,0,0.6)", width = 1)
#     )),
# 
#     bargap = 0.15
#   ) %>%
#   animation_slider(currentvalue = list(prefix = "Año: ")) %>%
#   animation_opts(frame = 600, easing = "linear", redraw = FALSE)
# 
# p
```

## Grafica Mapa

```{r}
# #Cargamos las geometrías de las comunidades autonomas
# 
# ccaa<-esp_get_ccaa(moveCAN = T) %>% st_as_sf()
# 
# # Modificamos los nombres de las comunidades para que sea mas friendly
#   
# ccaa<-ccaa %>%
#   mutate(
#     Territorio = ine.ccaa.name %>%
#       # 1) Quitar espacios extremos
#       str_squish() %>%
#       # 2) Quitar prefijo numérico
#       str_remove("^\\d+\\s+") %>%
#       # 3) Quedarse con lo anterior a la primera coma
#       str_remove(",.*$") %>%
#       # 4) Casos excepcionales
#       str_replace("Balears", "Baleares")
#   ) %>%
#   # Filtramos columnas inecesarias
#   select(Territorio,geometry)
# 
# #Unimos la info
# 
# CSE_map<- ccaa %>%
#   left_join(CSE_map, by = "Territorio")
# 
# 
# ```
# 
# ```{r}
# for (año in años) {
#   
#   # Mapa base
#   g_mapa <- CSE_map %>%
#     filter(Año == año) %>%
#     ggplot() +
#     geom_sf(aes(fill = Total), color = "white", linewidth = 0.25) +
#   
#     # Escala en grises
#     scale_fill_stepsn(
#       colours = grey(seq(0.9, 0.1, length.out = 7)),
#       n.breaks = 7,
#       trans = "sqrt",
#       na.value = "grey95",
#       name = "Suicidios",
#       labels = label_comma()
#     ) +
#   
#     # solo el mapa (sin título ni leyenda “encima”)
#     theme_void() + #esto me quita las coordenadas
#     theme(
#       panel.background = element_rect(fill = "grey95", color = NA),
#       plot.background  = element_rect(fill = "grey95", color = "grey80", linewidth = 0.6),
#       legend.position = "none",   # quitamos la leyenda aquí (la añadimos fuera)
#       
#     ) +
#     # Añadimos titulo y leyenda fuera
#     labs(title = paste("Suicidios por CCAA —", año)) +
#     theme(
#       plot.title.position = "plot",
#       plot.background = element_rect(fill = "white", color = NA),
#       panel.background = element_rect(fill = "grey95", color = NA),
#       legend.position = "right"
#     )
#   
#   print(g_mapa)
    
#}
```
```{r}


# # Escala fija (opcional) para que todos los años compartan el mismo máximo
# zmax <- max(CSE_map$Total, na.rm = TRUE)
# 
# # Paleta en grises (claro -> oscuro)
# pal_grey <- grey(seq(0.95, 0.2, length.out = 7))
# 
# p_mapa <- plot_ly() %>%
#   add_sf(
#     data  = CSE_map,
#     split = ~Territorio,            # una traza por CCAA
#     frame = ~Año,                   # <-- slider por año
#     color = ~Total,                 # colorear por Total
#     colors = pal_grey,              # paleta en grises
#     text = ~paste0(
#       "<b>", Territorio, "</b><br>",
#       "Suicidios: ", comma(Total)
#     ),
#     hoverinfo = "text",
#     stroke = I("white"),            # borde blanco entre CCAA
#     span = I(1)                     # relleno sólido del polígono
#   ) %>%
#   layout(
#     title  = list(text = "Suicidios por CCAA", x = 0.5, xanchor = "center",
#                   font = list(size = 22)),
#     margin = list(t = 80, r = 110, b = 20, l = 20),
#     # Barra de color (leyenda) a la derecha, fuera del mapa
#     coloraxis = list(
#       colorscale = list(c(0, pal_grey[1]), c(1, pal_grey[length(pal_grey)])),
#       cmin = 0, cmax = zmax,
#       colorbar = list(title = "Suicidios", len = 0.8, x = 1.04, y = 0.5)
#     ),
#     showlegend = FALSE
#   ) %>%
#   animation_slider(currentvalue = list(prefix = "Año: ")) %>%
#   animation_opts(frame = 600, easing = "linear", redraw = FALSE)
# 
# p_mapa

```


## Subsection Heading Here

.

### Subsubsection Heading Here

Bulleted lists look like this:

* First bullet
* Second bullet
* Third bullet

Numbered lists can be added as follows:

1. First item
2. Second item
3. Third item

The text continues here.

## Figures, Tables and Schemes

All figures and tables should be cited in the main text as Figure \ref{fig:fig1}, 
\ref{tab:tab1}, etc. To get cross-reference to figure generated by R chunks 
include the `\\label{}` tag in the `fig.cap` attribute of the R chunk: 
`fig.cap = "Fancy Caption\\label{fig:plot}"`.

```{r fig1, echo=FALSE, fig.width=3, fig.cap="A figure added with a code chunk.\\label{fig:fig1}"}
x = rnorm(10)
y = rnorm(10)
plot(x, y)
```


When making tables using `kable`, it is suggested to use
the `format="latex"` and `tabl.envir="table"` arguments
to ensure table numbering and compatibility with the mdpi
document class.

```{r tab1, echo=FALSE}
knitr::kable(mtcars[1:5, 1:3], format = "latex", 
             booktabs = TRUE, 
             caption = "This is a table caption. Tables should be placed in the 
             main text near to the first time they are~cited.", 
             align = 'ccc', centering = FALSE,
             table.envir = "table", position = "H")
```



For a very wide table, landscape layouts are allowed.


\startlandscape

```{r tab2, echo=FALSE}
df <- data.frame(`Title 1` = c("Entry 1", "Entry 2"),
                 `Title 2` = c("Data", "Data"),
                 `Title 3` = c("Data", "Data"),
                 `Title 4` = c("This cell has some longer content that runs over
                               two lines",
                               "Data"))
knitr::kable(df, format = "latex", 
             booktabs = TRUE, 
             caption = "This is a very wide table", 
             align = 'ccc', centering = FALSE,
             table.envir = "table", position = "H")
```

\finishlandscape

## Formatting of Mathematical Components

This is an example of an equation:

$$
a = 1.
$$

If you want numbered equations use Latex and wrap in the equation environment:

\begin{equation}
a = 1,
\end{equation}

the text following an equation need not be a new paragraph. Please punctuate 
equations as regular text.

```{comment}
If the documentclass option "submit" is chosen, please insert a blank line before and after any math environment (equation and eqnarray environments). This ensures correct linenumbering. The blank line should be removed when the documentclass option is changed to "accept" because the text following an equation should not be a new paragraph.
```

This is the example 2 of equation:

\begin{adjustwidth}{-\extralength}{0cm}
\begin{equation}
a = b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + 
u + v + w + x + y + z
\end{equation}
\end{adjustwidth}

Theorem-type environments (including propositions, lemmas, corollaries etc.) 
can be formatted as follows:

Example of a theorem:

::: {.Theorem latex=true}
Example text of a theorem
:::

The text continues here. Proofs must be formatted as follows:

Example of a proof:

::: {.proof latex="[Proof of Theorem1]"}
Text of the proof. Note that the phrase ``of Theorem 1'' is optional if it is 
clear which theorem is being referred to.
:::

The text continues here.

# Discussion

Authors should discuss the results and how they can be interpreted in 
perspective of previous studies and of the working hypotheses. The findings and 
their implications should be discussed in the broadest context possible. Future 
research directions may also be highlighted.

# Conclusion

This section is not mandatory, but can be added to the manuscript if the
discussion is unusually long or complex.

# Patents

This section is not mandatory, but may be added if there are patents resulting
from the work reported in this manuscript.
